name: Deploy Application

on:
  push:
    branches:
      - feature/aws-deployment-with-CI/CD
      - develop
  workflow_dispatch:

# Permission for GitHub Container Registry
permissions:
  contents: read
  packages: write

jobs:
  deploy-frontend:
    name: Deploy Frontend to Vercel
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          ref: develop
          
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Install Dependencies
        run: npm install
        working-directory: ./frontend
        
      - name: Install Vercel CLI
        run: npm install -g vercel
        
      - name: Deploy to Vercel
        run: |
          vercel --prod --yes \
            --token ${{ secrets.VERCEL_TOKEN }} \
            --scope ${{ secrets.VERCEL_ORG_ID }} \
            --build-env NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

  deploy-backend:
    name: Deploy Backend to AWS Lambda
    runs-on: ubuntu-latest
    needs: deploy-frontend
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          ref: develop

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Install Vercel CLI
        run: npm install -g vercel

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - name: Install AWS CLI
        run: pip install awscli
      
      - name: Create deployment package
        run: |
          cd backend
          
          # Create a modified requirements file without large packages
          grep -v "sentence-transformers\|torch\|tensorflow" requirements.txt > requirements-lambda.txt
          
          # Create function directory
          mkdir -p lambda_package
          
          # Copy all files except large ones
          cp *.py lambda_package/
          cp requirements-lambda.txt lambda_package/requirements.txt
          
          # Install dependencies
          pip install -r requirements-lambda.txt -t lambda_package/
          
          # Remove unnecessary files to reduce package size
          cd lambda_package
          find . -type d -name "__pycache__" -exec rm -rf {} +
          find . -type d -name "*.dist-info" -exec rm -rf {} +
          find . -type d -name "*.egg-info" -exec rm -rf {} +
          find . -type f -name "*.pyc" -delete
          
          # Create ZIP file
          zip -r ../function.zip .
          cd ..
      
      - name: Create/Ensure S3 bucket exists
        run: |
          # Check if bucket exists
          if ! aws s3api head-bucket --bucket ${{ secrets.LAMBDA_BUCKET_NAME }} 2>/dev/null; then
            echo "Creating S3 bucket for Lambda code..."
            aws s3 mb s3://${{ secrets.LAMBDA_BUCKET_NAME }} --region us-east-1
          fi
      
      - name: Upload Lambda package to S3
        run: |
          aws s3 cp backend/function.zip s3://${{ secrets.LAMBDA_BUCKET_NAME }}/reposage-backend-${{ github.sha }}.zip
      
      - name: Create/Update Lambda function
        run: |
          # Check if function exists
          if aws lambda get-function --function-name reposage-backend 2>&1 | grep -q "Function not found"; then
            echo "Creating new Lambda function..."
            # Create function from S3
            aws lambda create-function \
              --function-name reposage-backend \
              --runtime python3.9 \
              --handler app.handler \
              --role ${{ secrets.LAMBDA_EXECUTION_ROLE }} \
              --code S3Bucket=${{ secrets.LAMBDA_BUCKET_NAME }},S3Key=reposage-backend-${{ github.sha }}.zip \
              --timeout 30 \
              --memory-size 1024 \
              --environment "Variables={GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }},ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }},GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }},ENCRYPTION_KEY=${{ secrets.ENCRYPTION_KEY }},SECRET_KEY=${{ secrets.SECRET_KEY }},FRONTEND_URL=${{ secrets.FRONTEND_URL }},DATABASE_URL=sqlite:///tmp/reposage.db,REDIS_URL=redis://localhost:6379/0}"
          else
            echo "Updating existing Lambda function..."
            # Update function code from S3
            aws lambda update-function-code \
              --function-name reposage-backend \
              --s3-bucket ${{ secrets.LAMBDA_BUCKET_NAME }} \
              --s3-key reposage-backend-${{ github.sha }}.zip
          fi
      
      - name: Create/Update API Gateway
        id: create-api
        run: |
          # Check if API exists
          API_ID=$(aws apigateway get-rest-apis --query "items[?name=='reposage-api'].id" --output text)
          
          if [ -z "$API_ID" ]; then
            echo "Creating new API Gateway..."
            # Create API
            API_ID=$(aws apigateway create-rest-api --name reposage-api --query "id" --output text)
            
            # Get root resource ID
            ROOT_ID=$(aws apigateway get-resources --rest-api-id $API_ID --query "items[?path=='/'].id" --output text)
            
            # Create proxy resource
            RESOURCE_ID=$(aws apigateway create-resource --rest-api-id $API_ID --parent-id $ROOT_ID --path-part "{proxy+}" --query "id" --output text)
            
            # Set up ANY method
            aws apigateway put-method --rest-api-id $API_ID --resource-id $RESOURCE_ID --http-method ANY --authorization-type NONE
            
            # Set up Lambda integration
            aws apigateway put-integration --rest-api-id $API_ID --resource-id $RESOURCE_ID --http-method ANY --type AWS_PROXY --integration-http-method POST --uri arn:aws:apigateway:us-east-1:lambda:path/2015-03-31/functions/arn:aws:lambda:us-east-1:${{ secrets.AWS_ACCOUNT_ID }}:function:reposage-backend/invocations
            
            # Create deployment
            aws apigateway create-deployment --rest-api-id $API_ID --stage-name prod
            
            # Grant permission to API Gateway
            aws lambda add-permission --function-name reposage-backend --statement-id apigateway-prod --action lambda:InvokeFunction --principal apigateway.amazonaws.com --source-arn "arn:aws:execute-api:us-east-1:${{ secrets.AWS_ACCOUNT_ID }}:$API_ID/prod/*/*"
          else
            echo "API Gateway already exists, updating deployment..."
            # Create a new deployment
            aws apigateway create-deployment --rest-api-id $API_ID --stage-name prod
          fi
          
          # Set API endpoint
          API_ENDPOINT="https://$API_ID.execute-api.us-east-1.amazonaws.com/prod"
          echo "API_ENDPOINT=$API_ENDPOINT" >> $GITHUB_ENV
          echo "API endpoint: $API_ENDPOINT"
      
      - name: Update Vercel Environment Variables
        run: |
          vercel env add NEXT_PUBLIC_API_URL ${{ env.API_ENDPOINT }} --token ${{ secrets.VERCEL_TOKEN }} --scope ${{ secrets.VERCEL_ORG_ID }} --project ${{ secrets.VERCEL_PROJECT_ID }} --yes
          vercel deploy --prod --token ${{ secrets.VERCEL_TOKEN }} --scope ${{ secrets.VERCEL_ORG_ID }} --project ${{ secrets.VERCEL_PROJECT_ID }} --yes
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}